---
title: "Hardware Exploits - An Overview"
date: 2023-10-28T13:57:05+02:00
summary: "Meltdown, Spectre, Rowhammer &amp; more - What are they about?"
weight: 100
tags: ['computer science', 'security', 'hardware']
---

## CPU Exploits

### Cache Timing Attacks

Cache timing attacks cover a wide range of attacks which rely on timing memory accesses to determine whether a value is in the cache or not.

Such attacks are potent against badly designed cryptography libraries, but with some creativity they can become a threat in many areas.
[Previous research](https://download.vusec.net/papers/anc_ndss17.pdf) has shown it possible to derandomize ASLR by relying on timing MMU page table walks to uncover addresses, even in sandboxed environments.
[Other methods](https://www.cs.columbia.edu/~simha/spyjs.ccs15.pdf) have been presented which allow tracking of user behaviour through untrusted webpages.

<figure class="w-3/5 float-right m-0 ml-5 mt-[-1em]">

```C
byte T_Table[128] = { ... };

byte sign_msg(byte msg, byte key) {
    if (key == 0) {
        return msg ^ T_Table[0];
    }
    return msg ^ T_Table[64];
}
```

<figcaption class="text-center">

An example crypto function that could be exploited.
If the key is 0, then the attacker can observe a cache hit on `T_Table[0]`.
Else, the entry `T_Table[64]` is hot.

</figcaption>

</figure>

The general way cache timing attacks work is by first removing a certain memory location from the cache by some means.
This can be achieved using a `clflush` instruction or by evicting the data entry, the latter of which being a bit more involved of a method.
The attacker then performs some operation like calling a library function, inducing an address translation, etc.
In the last step, the attacker times the access to the memory location again.
If the memory access is quick, the attacker can deduce that a cache hit occurred, meaning the victim must have accessed the memory location.
If the access takes long, however, the attacker knows that no access to the memory location has been performed by the victim.

Another way of performing a cache timing attack that doesn't just measure one memory location at a time is by using the PRIME+PROBE method.
In this method, an attacker allocates a chunk of memory which covers one full cache set.
For simplicities sake, let's assume that the attacker has an array of memory pointers, where the pointers together cover a cache set.
This means that the length of the array is equal to the wayness of the cache and that every element in this array points to the same cache set.
If the elements in the array are now accessed sequentially, this means that the targeted cache set is now populated with exactly these memory locations.
Accessing these elements again will now always lead to a cache hit.
The attacker can then measure the access times to the elements again at a later point, be this after some time passed or after the attacker triggered a certain action.
This access time can now give the attacker an understanding of memory accesses made by the victim, which can for example be used to profile users in browsers through a malicious ad.

Mitigations to such attacks may include using constant-time algorithms such that memory accesses are always deterministic and don't change with different parameters, such as keys or other secrets.
Defenders have also tried to mitigate such timing attacks in browsers by worsening their timers, making them more inaccurate.
The intent behind this was to make it impossible to differentiate between cache hits and cache misses.
This method has flaws however, as artificial noise can be eliminated through repeated measurements, and making the timers too inaccurate could interfere with legitimate applications.
Additionally, researchers were able to create timers through other means which circumvent this mitigation.

### Transient Execution Vulnerabilities

In order to improve CPU performance, modern CPUs use speculative execution.
This allows CPUs to run instructions out of order, thereby making stalls (e.g. from a slow memory access) less impactful.

With transient execution, CPUs commit or rollback instructions when they are completed or have become invalid (for example if a branch was mispredicted).
However, when rolling back instructions, the microarchitectural state, which includes caches and certain buffers, does not get reverted.
These microarchitectural remains provide attackers with a side-channel for extracting information.

{{< figure src="/blog/hardware-exploits/meltdown.svg" class="float-left w-8 m-0 mt-2 mr-5" nozoom=true >}}

#### Meltdown

[Original Paper on Meltdown](https://meltdownattack.com/meltdown.pdf)

Meltdown was the first hardware attack exploiting transient execution in CPUs.

<figure class="w-min float-right m-0 ml-5 mt-[-1em]">

```C
byte *kernel_ptr = ... ;
byte arr[256 * 64];

arr[*kernel_ptr * 64];
```

<figcaption class="text-center">

A toy-example of the meltdown attack.
If the value at `*kernel_ptr` is `x`, then the entry `arr[x * 64]` will be hot.

</figcaption>

</figure>

It is very simple in its functionality.
In some CPUs, when the CPU has to access a memory location, it performs the access and permission checks in parallel, leading to a race condition.
This means that it is possible to induce an illegal memory access and perform operations on the acquired value before the CPU raises an exception.
Attackers can use this behaviour to prime other memory locations which they can later time to differentiate between a cache hit or miss.

The only detail attackers must consider is how to suppress the induced segfault due to the illegal memory access.
This is easily done by registering a signal handler or using other methods, such as Intel TSX.

Only some CPUs were affected by this vulnerability, as not all perform the permission check in parallel with the memory access.
Meltdown primarily affected Intel x86 CPUs, but the ARM Cortex-A75 and IBM's Power microprocessor were also vulnerable.

With the vulnerability being disclosed, many mitigations were implemented by Linux kernel developers, Microsoft, Apple and more.
In the Linux kernel for example, developers implemented kernel page-table isolation (KPTI), which hardens the kernel by better isolating user space and kernel space memory.  
Newer Intel CPUs are no longer affected by this vulnerability, with Intel including hardware patches.
They also released microcode updates for some older CPUs which mitigate the Meltdown vulnerability.

{{< figure src="/blog/hardware-exploits/spectre.svg" class="float-left w-10 m-0 mt-4 mr-3" nozoom=true >}}

#### Spectre

[Original Paper on Spectre](https://spectreattack.com/spectre.pdf)

##### v1
##### v2
##### v3

#### Phantom

#### Retbleed

## RAM Exploits

### Rowhammer

## Other Sidechannel Attacks

### Tempest

### Power Analysis